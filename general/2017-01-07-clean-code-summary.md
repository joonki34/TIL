# Clean Code 요약

## Chapter 1 - 깨끗한 코드

쓸데없어서 스킵

## Chapter 2 - 의미 있는 이름

1\. 소문자 L이나 대문자 O는 피해라

2\. Info나 Data 같은 의미가 불분명한 용어는 쓰지 말라 (e.g. ProductInfo,
ProductData)

3\. (발음하기 쉬운 이름을 사용하라)

4\. 검색하기 쉬운 이름을 사용하라

5\. Hungarian notation 사용하지 말라

6\. 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.

-   좋은 예: Customer, WikiPage, Account, AddressParser

-   나쁜 예: Manage, Processor, Data, Info

7\. 생성자를 중복정의할 때는 정적 팩토리 메서드를 사용한다.

-   Complex fulcrumPoint = Complex.FromRealNumber(23.0);

-   Complex fulcrumPoint = new Complex(23.0);

8\. 한 개념에 한 단어를 사용하라

-   똑같은 메서드를 fetch, retrieve, get으로 제각각 부르면 헷갈린다.

-   마찬가지로 controller, manager, driver를 섞어쓰면 혼란스럽다.

9\. 전산용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.

-   AccountVisitor는 visitor 패턴을 썼다는 것을 알 수 있다.

10\. 인터페이스 이름은 접두어를 붙이지 마라 (e.g. IShapeFactory)

-   ShapeFactory라고 하고 구현 클래스를 ShapeFactoryImpl라고 하는게 차라리 낫다

11\. 연속적인 숫자를 덧붙인 이름 (e.g. a1, a2)은 지양하라. source,
destination이 더 낫다.

12\. 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면 accountList라고
명명하지 말라. 프로그래머에게 List는 특수한 의미다. accountGroup,
bunchOfAccounts, Accounts 등이 낫다.

## Chapter 3 - 함수

1\. 작게 만들어라

-   들여쓰기 수준은 1단이나 2단을 넘어서면 안된다

2\. 한 가지만 해라

-   모든 문장의 추상화 수준이 동일해야한다.

3\. 위에서 아래로 읽히도록 작성하라.

4\. switch 문은 다형적 객체를 생성하는 코드 안에서만 사용하라.

5\. 서술적인 이름을 사용하라.

6\. 이상적인 인수 개수는 0개, 그 다음 1개, 그 다음 2개다. 2개 이상은
가능한 피하라.

7\. 플래그 인수는 쓰지마라.

-   함수가 한꺼번에 여러 가지를 처리한다고 대놓고 말하는 셈이다.

8\. 인수 객체

-   인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 수 있다.

    -   Circle makeCircle(double x, double y, double radius);

    -   Circle makeCircle(Point center, double radius);

9\. 인수 목록

-   인수 개수가 가변적인 함수일 경우 Object...를 사용한다. (Java 기준)

10\. 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.

-   write(name) 좋다. writeField(name)는 더 명확하다.

-   assertEquals보다 assertExpectedEqualsActuals가 더 명확하다.

11\. 오류코드보다 예외를 사용하라.

-   try/catch 블록은 별도 함수로 뽑아내라.

12\. **반복하지 마라!!**

## Chapter 4 - 주석

1\. 주석은 기껏해야 필요악이다. 가능한 줄여라.

2\. 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁘다.

3\. 좋은 주석 (그래도 주석을 달지 않도록 코드를 짜는게 더 좋다.)

-   법적인 주석 (e.g. 라이센스)

-   의도를 설명하는 주석

-   정보를 제공하는 주석

    -   사용된 알고리즘 설명

-   결과를 경고하는 주석

    -   “SimpleDateFormat은 스레드에 안전하지 못하다. 따라서 각 인스턴스를 독립적으로 생성해야 한다."

-   TODO 주석

-   중요성을 강조하는 주석

    -   “여기서 trim은 정말 중요하다. 왜냐하면 \~\~"

4\. 나쁜 주석

-   주절거리는 주석 (마지못해 다는 주석)

-   같은 이야기를 중복하는 주석 (코드 내용을 중복 설명하는 주석)

-   오해할 여지가 있는 주석

-   의무적으로 다는 주석 (e.g. 모든 함수에 Javadocs 달기)

-   닫는 괄호에 다는 주석 (e.g. //end while)

    -   대신 함수의 크기를 줄여라

-   공로를 돌리거나 저자를 표시하는 주석 (e.g. 릭이 추가함)

    -   소스 코드 관리 시스템이 해줌

-   주석으로 처리한 코드

    -   소스 코드 관리 시스템이 해줌

-   HTML 주석 (Javadocs 안에서의 HTML 주석 e.g. &lt;pre&gt;)

-   함수 헤더

    -   짧은 함수는 긴 설명이 필요 없다.

## Chapter 5 - 형식 맞추기

1\. 평균적으로 파일 크기는 200줄 정도가 적당하다. 물론 적을수록 좋다.

2\. 고차원과 알고리즘부터 묘사하여 마지막에는 저차원 함수와 세부내역이
나오도록 한다.

3\. 개념을 빈 행으로 분리하라.

4\. 서로 밀접한 코드 행은 세로로 가까이 놓아라.

5\. 변수는 사용하는 위치에 최대한 가까이 선언하라.

6\. 인스턴스 변수는 클래스 맨 처음에 선언한다.

7\. 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.

-   가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.

8\. 한 행은 80\~120자 제한이 적절하다.

9\. 가로 정렬은 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려지게 해서
별로다.

10\. 팀규칙은 무조건 지켜라.

## Chapter 6 - 객체와 자료 구조

1\. 객체 vs. 자료구조

-   객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.

-   자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.

-   (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

-   절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

-   복잡한 시스템을 짜다보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생긴다. 이 때는 객체 지향 기법이 적합. 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우에 절차적인 코드와 자료 구조가 적합

2\. 디미터 법칙이란 모듈은 자신이 조작하는 개체의 속사정을 몰라야 한다는
법칙이다.

-   이 맥락으로 본 class C 의 메소드 m 이 호출할 수 있는 범위

    -   C

    -   f 내부에 생성된 객체

    -   f의 parameter

    -   C 인스턴스 변수

3\. 자료 구조체는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료
구조체를 때로는 자료 전달 객체(DTO)라 한다.

4\. 활성 레코드는 DTO의 특수한 형태로 공개 변수가 있거나 비공개 변수에
조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도
제공한다.

-   활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.

-   활성 레코드를 객체로 취급하여 비즈니스 규칙 메서드를 추가하면 안된다. 자료 구조로 취급해야 한다.

5\. 결론: 객체는 동작을 공개하고 자료를 숨긴다. 자료 구조는 자료를
노출한다.

## Chapter 7 - 오류 처리

1\. 오류 코드보다 예외를 사용하라

2\. 가능한 unchecked exception을 쓰라. Checked exception 적용 시 하위
단계에서 예외 처리를 변경하면 상위 단계까지 전부 수정해야한다.

3\. 예외에 의미를 제공하라. 오류 메시지에 정보를 담아 예외와 함께 던져라.

4\. null을 반환하지 마라.

-   null을 반환하는 코드는 매번 null을 확인하는 코드를 넣게 만든다.

-   예를 들어, list의 경우 null이 아닌 empty list(e.g. Collections.emptyList())를 반환해라.

5\. null을 전달하지마라.

6\. 오류 처리를 프로그램 논리와 분리해 독립적인 사안으로 고려하면 깨끗한
코드를 작성할 수 있다.

7\. 감싸기 기법(wrapper class)를 사용하면 오류를 처리하기 용이하다.
감싸고 exception도 감싸서 구현하면 된다. 특정 업체가 API를 설계한 방식에
발목 잡히지도 않는다.

## Chapter 8 - 경계

인터페이스 제공자는 적용성을 최대한 넓히려 하는 반면에, 사용자는 자신의
요구에 집중하는 인터페이스를 바란다.

예를 들어, Map의 clear() 메소드를 이용하면 누구나 Map 내용을 지울 수
있다.

경계 인터페이스인 Map을 커스텀 클래스 안으로 숨기면 Map 인터페이스가
변하더라도 나머지 프로그램에는 영향을 미치지 않는다.

우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트
케이스를 작성해 외부 코드를 익히는 것은 바람직하다. 이를 학습 테스트라
한다.

경계에 위치하는 코드는 깔끔히 분리한다.

## Chapter 9 - 단위 테스트

1\. TDD 법칙 세가지

-   실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.

-   컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.

-   현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

2\. TDD 규칙을 따르면 개발과 테스트가 30초 주기로 묶이고 방대한 테스트
케이스가 나온다. 많은 양의 테스트 코드는 심각한 관리 문제를 유발하기도
한다.

3\. 테스트 코드도 실제 코드처럼 깨끗하게 유지해라.

4\. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 테스트 케이스가
있으면 공포가 사라진다. 안심하고 아키텍처와 설계를 개선할 수 있다.

5\. 테스트 코드엔 가독성이 굉장히 중요하다.

6\. 테스트 함수 하나 당 assert문을 단 하나만 사용한다는 규칙은 장점이
잇다.

7\. F.I.R.S.T 규칙 (깨끗한 테스트를 위한 다섯가지 규칙)

-   Fast: 테스트는 빨라야 한다. 느리면 돌릴 엄두를 못 낸다.

-   Independent: 각 테스트는 서로 의존하면 안 된다. 어떤 순서로 실행해도 괜찮아야 한다.

-   Repeatable: 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경 등 모든 환경에서 테스트가 돌아가야 한다. 아니라면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.

-   Self-Validating: 테스트는 bool 값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 해서는 안 된다.

-   Timely: 테스트는 적시에 작성해야 한다. 단위 테스트는 실제 코드 구현 직전에 구현한다. 실제 코드 구현 후에 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.

## Chapter 10 - 클래스

1\. 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫다.

2\. 클래스는 작아야 한다. 맡은 책임이 하나여야 한다.

3\. 클래스 이름은 해당 클래스 책임을 기술해야 한다. 간결한 이름이
떠오르지 않는다면 클래스 크기가 너무 커서 그런 것이다.

4\. 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야
한다는 원칙이다.

5\. 응집도

-   클래스는 인스턴스 변수 수가 작아야 한다.

-   메서드가 변수를 더 많이 사용할수록 메서드와 클래스의 응집도가 더 높다.

-   모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.

-   응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문이다.

-   응집도를 유지하면 작은 클래스 여럿이 나온다.

6\. OCP(Open-Closed Principle)이란 클래스는 확자에 개방적이고 수정에
폐쇄적이어야 한다는 원칙이다. 새 기능을 수정하거나 기존 기능을 변경할 때
건드릴 코드가 최소인 시스템 구조가 바람직하다.

7\. 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리하라.

## Chapter 11 - 시스템

DI, AspectJ와 관련된 글이 있었는데 별로 도움은 안되서 안씀

## Chapter 12 - 창발성

창발성: 개별 요소에서는 특성이 없던 것이 집단을 이루면서 어떤 특정
현상을 발생시키는 것

착실하게 따르기만 하면 우수한 설계가 나오는 간단한 규칙 네 가지가
있다면?

켄트 백은 다음 규칙을 따르면 설계는 ‘단순하다’고 말한다.

-   모든 테스트를 실행한다.

    -   테스트가 불가능한 시스템은 검증도 불가능하다.

    -   테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 좋아진다.

    -   결합도가 높으면 테스트 케이스를 작성하기 어렵다. DIP와 같은 원칙을 적용하고 의존성 주입, 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮추면 테스트 케이스 작성이 쉬워진다.

    -   테스트 케이스가 있으면 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다.

-   중복을 없앤다.

    -   비슷한 코드는 더 비슷하게 고쳐주면 리팩터링이 쉬워진다.

-   프로그래머 의도를 표현한다.

    -   코드는 개발의 의도를 분명히 표현해야 다른 사람이 이해하기 쉬워진다.

    -   클래스와 함수를 위해 좋은 이름을 선택한다.

    -   함수와 클래스 크기는 가능한 줄인다.

    -   표준 명칭을 사용한다. Visitor 같은 표준 패턴을 사용해 구현한다면 클래스 이름에 패턴 이름을 넣어준다.

    -   단위 테스트를 꼼꼼히 작성한다.

    -   나중에 코드를 읽을 사람은 자신일 가능성이 높다.

-   클래스와 메서드 수를 최소로 줄인다.

    -   클래스와 메서드 크기를 너무 많이 줄이면 조그만 클래스와 메서드를 수없이 만들 수도 있다. 가능한 줄여라.

    -   이 규칙은 우선순위가 가장 낮다. 다시 말해, 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.

(위 목록은 중요도 순이다.)

## Chapter 13 - 동시성

동시성 관련은 다른 책을 보자.

## Chapter 14 - 점진적인 개선

예제를 통해 리팩터링하는 것을 보여줘서 설명하기 힘들다.

## Chapter 15 - JUnit 들여다보기

예제가 JUnit

## Chapter 16 - SerialDate 리팩터링

예제가 SerialDate

## Chapter 17 - 냄새와 휴리스틱

주석

-   부적절한 정보: 다른 시스템(e.g. 소스 코드 관리 시스템) 등에 정할 정보는 주석으로 부적절하다. 작성자, 최종 수정일 등과 같은 메타 정보만 주석으로 넣는다.

-   쓸모 없는 주석: 쓸모 없어질 주석은 달지 않는 편이 가장 좋다.

-   중복된 주석: 코드만으로 충분한데 구구절절 설명하는 주석은 중복된 주석이다. 주석은 코드만으로 다하지 못하는 설명을 부언하다.

-   성의 없는 주석: 주석을 달 참이라면 시간을 들여 최대한 간결 명료하고 신중하게 작성한다.

-   주석 처리된 코드: 주석 처리된 코드는 얼마나 오래된 코드인지, 중요한 코드인지 알 길이 없다. 누군가에게 필요할거라 생각되기 때문에 아무도 삭제하지 못한다. 소스 코드 관리 시스템이 기억하니 지워야 한다.

환경

-   여러 단계로 빌드해야 한다: 빌드는 간단히 한 단계로 끝나야 한다.

-   여러 단계로 테스트해야 한다: 모든 단위 테스트는 한 명령으로 돌려야한다.

함수

-   너무 많은 인수: 함수에서 인수 개수는 작을수록 좋다. 넷 이상은 최대한 피한다.

-   출력 인수: 출력 인수는 직관을 정면으로 위배한다. 일반적으로 독자는 인수를 (출력이 아니라) 입력으로 간주한다. 함수에서 뭔가의 상태를 변경해야 한다면 (출력 인수를 쓰지 말고) 함수가 속한 객체의 상태를 변경한다.

-   플래그 인수: 플래그 인수는 함수가 여러 기능을 수행한다는 명백한 증거다. 피해야 마땅하다.

-   죽은 함수: 아무도 호출하지 않는 함수는 삭제한다. 소스 코드 간리 시스템이 모두 기억한다.

일반

-   한 소스 파일에 여러 언어를 사용한다: 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.

-   당연한 동작을 구현하지 않는다: 당연한 동작을 구현하지 않으면 코드를 읽는 사람이 함수 이름만으로 함수 기능을 예상하기 어렵다.

-   안전 절차 무시: 컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질지 모르지만 후에 고생할 수 있다. 실패하는 테스트 케이스를 나중으로 미루는 태도는 위험하다.

-   중복: DRY(Don’t Repeat Yourself) 원칙을 명심한다. 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라.

-   추상화 수준이 올바르지 못하다: 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.

-   기초 클래스가 파생 클래스에 의존한다: 기초 클래스가 파생 클래스를 사용하면 안된다. 기초 클래스는 파생 클래스를 아예 몰라야 정상이다.

-   과도한 정보: 잘 정의된 인터페이스는 많은 함수를 제공하지 않고 결합도가 낮다. 부실하게 정의된 인터페이스는 반드시 호출해야 하는 온갖 함수를 제공해서 결합도가 높다. 클래스가 제공하는 메소드 수는 작을수록 좋다. 클래스에 들어있는 인스턴스 변수 수도 작을수록 좋다.

-   죽은 코드: 실행되지 않는 코드는 삭제해야 한다.

-   수직 분리: 변수와 함수는 사용되는 위치에 가깝게 정의한다. 지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치해야 한다. 선언한 위치로부터 몇백 줄 아래에서 사용하면 안된다.

-   일관성 부족: 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현해야 코드를 읽고 수정하기 쉬워진다.

-   잡동사니: 아무도 사용하지 않는 변수, 함수, 주석 등은 제거해야 마땅하다.

-   인위적 결합: 서로 무관한 개념을 인위적으로 결합하지 않는다. 예를 들어, 일반적인 enum은 특정 클래스에 속할 이유가 없다.

-   기능 욕심: 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안 된다. 자신이 그 클래스에 속해 그 클래스 변수를 직접 조작하고 싶다는 뜻이다. 어쩔 수 없는 경우도 생긴다.

-   선택자 인수: 함수 호출 끝에 달리는 false 인수는 좋지 않다. 선택자 인수는 목적을 기억하기 어렵고 각 선택자 인수가 여러 함수를 하나로 조합한다. enum, int등 함수 동작을 제어하려는 인수는 하나 같이 바람직하지 않다. 일반적으로, 대신 새로운 함수를 만드는 편이 좋다.

-   모호한 의도: 코드를 짤 때는 의도를 최대한 분명히 밝힌다.

-   부적절한 static 함수: 특정 인스턴스와 관련된 기능이 아니면 static 함수가 바람직하다. 하지만 재정의가 필요하다면 바람직하지 않다.

-   서술적 변수: 서술적인 변수 이름은 많이 써도 괜찮다. 계산을 몇 단계로 나누고 중간값에 좋은 변수 이름만 붙여도 읽기 쉬워진다. (e.g. String key = match.group(1); String value = match.group(2); )

-   이름과 기능이 일치하는 함수: 이름과 기능이 일치해야 무슨 일을 하는 함수인지 유추하기 쉽다.

-   알고리즘을 이해하라: 알고리즘을 명확히 이해해야 함수를 깔끔하고 명확하게 재구성할 수 있다.

-   논리적 의존성은 물리적으로 드러내라: 한 모듈이 다른 모듈에 의존할 때는 물리적으로도 의존해야 한다.

-   If/Else 혹은 Switch/Case 문보다 다형성을 사용하라: switch 문보단 다형성을 먼저 고려하라.

-   표준 표기법을 따르라: 업계 표준에 기반한 구현 표준을 따라서 표준을 설명하는 별도의 문서가 없도록 한다.

-   매직 숫자를 명명된 상수로 교체하라: 코드에서 숫자보단 명명된 상수를 사용하는 것이 바람직하다. 하지만 어떤 상수는 이해하기 쉬우므로 상수 뒤로 숨길 필요는 없다. (e.g. FEET\_PER\_MILE)

-   관례보다 구조를 사용하라: 설계 결정을 강제할 때는 규칙보다 관례를 사용한다. 명명 관례도 좋지만 구조 자체로 강제하면 더 좋다. 예를 들어, switch/case보다는 추상 메서드가 있는 기초 클래스를 쓰면 더욱 강제가 된다.

-   조건을 캡슐화하라: if(timer.hasExpired() && !timer.isRecurrent()) 보다는 if(shouldBeDeleted(timer))가 더 좋다.

-   부정 조건을 피하라: 부정 조건은 긍정 조건보다 이해하기 어려우므로 피한다.

-   함수는 한 가지만 해야 한다: 함수 하나는 임무 하나만 수행해야 한다.

-   숨겨진 시간적인 결합: 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러내도록 한다.

    -   saturateGradient();

    -   reticulateSpline();

    -   보다는

    -   Gradient gradient = saturate Gradient();

    -   List&lt;Spline&gt; splines = reticulateSplines(gradient);

    -   로 하여 시간적인 결합을 노출하는 것이 좋다.

-   일관성을 유지하라: 시스템 전반에 걸쳐 구조가 일관성이 있어야 남들도 그것을 따르고 보존한다.

-   경계 조건을 캡슐화하라: 경계 조건은 빼먹거나 놓치기 십상이다. 코드 여기저기에 +1이나 -1을 흩어놓지 않고 한 곳에서 별도로 처리하도록 한다.

    -   if (level + 1 &lt; length) 보다는

    -   int nextLevel = level + 1;

    -   if (nextLevel &lt; length) 가 더 좋다.

    -   경계 조건이란?: [*http://www.answers.com/Q/What\_are\_boundary\_conditions\_in\_computer\_science*](http://www.answers.com/Q/What_are_boundary_conditions_in_computer_science)

-   함수는 추상화 수준을 한 단계만 내려가야 한다: 함수 내 모든 문장은 추상화 수준이 동일해야 하고 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.

-   설정 정보는 최상위 단계에 둬라: 추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안 된다. 대신 고차원 함수에서 저차원 함수를 호출할 때 인수로 넘긴다.

-   추이적 탐색을 피하라: 한 듈은 주변 모듈을 모를수록 좋다. 자신이 직접 사용하는 모듈만 알아야 한다.

자바

-   긴 import 목록을 피하고 와일드카드를 사용하라

    -   import package.\*;

    -   내 생각: 장단점이 있을 듯. 요즘 IDE는 import 목록을 숨겨줘서 가독성에 문제를 주진 않음

-   상수를 상속하지 않는다: 어떤 프로그래머는 상수를 인터페이스에 넣은 다음 그 인터페이스를 상속해 해당 상수를 사용한다. 이것보다는 상속이 아니라 static import로 사용하는 것이 좋다.

-   상수 vs. Enum: public static final int 같은 방법은 코드에서 의미를 잃어버리기도 한다. enum은 그렇지 않은데다가 int보다 훨씬 더 유연하고 서술적이다.

이름

-   서술적인 이름을 사용하라: 가독성의 90%는 이름이 결정한다.

-   적절한 추상화 수준에서 이름을 선택하라: 구현을 드러내는 이름보다는 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라. 추상화 수준이 너무 낮은 이름은 좋지 않다.

-   가능하다면 표준 명명법을 사용하라: 기존 명명번을 사용하는 이름은 이해하기 더 쉽다. 예를 들어, decorator 패턴을 활용한다면 클래스 이름에 decorator라는 단어를 사용한다.

-   명확한 이름: 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.

-   긴 범위는 긴 이름을 사용하라: 범위가 길면 긴 이름을 사용한다. 범위가 짧으면 i나 j와 같은 변수 이름도 괜찮다.

-   인코딩을 피하라: Hungarian notation 같이 이름 앞에 접두어를 쓸 필요가 없다. (UTF-8 같은 인코딩 아님)

테스트

-   불충분한 테스트: 테스트 케이스는 잠재적으로 깨질만한 부분을 모두 테스트해야 한다.

-   커버리지 도구를 사용하라

-   사소한 테스트를 건너뛰지 마라

-   무시한 테스트는 모호함을 뜻한다: 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다.

-   경계 조건을 테스트하라: 경계 조건은 각별히 신경 써서 테스트한다. 알고리즘의 중앙 조건은 올바로 짜놓고 경계 조건에서 실수하는 경우가 흔하다.

-   버그 주변은 철저히 테스트하라: 버그는 서로 모이는 경향이 있다. 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.

-   실패 패턴을 살펴라

-   테스트 커버리지 패턴을 살펴라

-   테스트는 빨라야 한다: 느린 테스트 케이스는 실행하지 않게 된다.
