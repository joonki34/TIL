# File Descriptor

유닉스 시스템에서 모든 것은 파일이다. 일반적인 정규파일에서부터 디렉토리, 소켓, 파이프, 블록 디바이스, 캐릭터 디바이스 등등 모든 객체들은 파일로써 관리된다. 유닉스 시스템에서 프로세스가 이 파일들을 접근할 때에 파일 디스크립터라는 개념을 이용한다.

파일 디스크립터는 Non-negative integer 값을 갖는다. 프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중에 사용하지 않는 가장 작은 값을 할당해 준다. 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근 할 때, FD 값을 이용해 파일을 지칭 할 수 있다.

프로그램이 프로세스로 메모리에서 실행을 시작 할 때, 기본적으로 할당되는 파일 디스크립터들이 있다. 바로 표준 입력(Standard Input), 표준 출력(Standard Output), 표준 에러(Standard Error)이다. 이 들에게 각각 0, 1, 2 라는 정수가 할당되며, POSIX 표준에서는 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO로 참조된다.

리다이렉션(redirection, 재지향)은 열려있는 파일의 입출력을 다른 파일로 변환할 때 사용된다. 리다이렉터는 `>`로 나타내며, 쉽게, "모든 출력은 꺽쇠의 방향으로!" 라고 이해하면 된다. 

리다이렉션은 파일 디스크립터와 함께 사용될 수 있으며, 몇 가지 예를 들면 아래와 같다.

- `> file` : 표준 출력을 파일로 보낸다.
- `1> file` : 위와 동일하다. > 앞의 1은 표준 출력에 대한 파일 디스크립터를 나타낸다. 
- `2> file` : 에러 출력을 file 로 보낸다.
- `< file` : file로부터 표준 입력을 받는다.
- `0< file` : 위와 동일하다. < 앞의 0은 표준 입력 파일 디스크립터를 나타낸다.
- `i>&j` : i번 파일 디스크립터를 j번 파일 디스크립터로 리다이렉트한다. 즉, i가 가리키는 파일의 모든 출력은 j가 가리키는 파일로 보낸다. 

따라서, 위 문제점에서의 구문은 아래와 같은 형태로 정리될 수 있다.
`$cat notexist > /dev/null 2>&1`

- `cat notexist` : notexist 파일의 내용을 조회해서,
- `>` : (표준 출력으로) 나오는 결과를 다음 파일로 보낸다.
- `/dev/null` : 유닉스의 블랙홀과 같은 파일이다. 이 파일을 모든 출력을 흡수한다. (보이지 않는다.)
- `2>` : 에러 메세지가 발생할 경우에는, 즉 에러 출력을,
- `&1` : 1번 표준 출력 파일 디스크립터가 참조하고 있는 곳으로 보낸다.

즉, 조회한 내용과 발생한 에러 모두 표시하지 않겠다는 뜻이었다.

## References

<http://dev-ahn.tistory.com/m/96>
<http://ohgyun.com/328>